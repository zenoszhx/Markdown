# 管理模式

管理模式与工厂模式、单例模式、外观模式都是程序设计的一种模式。不过管理模式的实现相对复杂一点。

### 1.引擎当中的应用

管理模式的类就是专门管理其他类的对象。通常管理模式只会负责管理一种类型的对象。比如纹理资源只有一个纹理对象管理类、精灵资源只有一个精灵资源管理类。

除了上表中的管理模式之外，引擎中还存在一些其他的管理类,比如定时器、字体。

管理有常见的三个特点：

1）只会存在一个管理者。在引擎中任何一种资源只有一个管理者。例如自动释放池，虽然程序中可能有很多个自动释放池对象，但是池管理者却只有一个。为了保证管理者的唯一，管理模式的对象都会是单例。这些对象中大多会存在两个关键字“getInstance”和“destroyInstance”。

	// 静态函数，返回管理者的单例对象
	static AnimationCache* getInstance(void);

	// 表达函数，释放管理者的单例对象
	static void destroyInstance(void);

2)管理对象功能，负责管理对象的创建各销毁。在一些管理者中，创建对象的方式会采用工厂模式。例如精灵帧缓冲的管理者创建精灵帧的方式就是工厂模式。精灵帧对象会以键值方式被管理。开发者可以通过函数自由的访问每一个对象帧。这些函数有名字中通常会出现两个关键字“add”和"remove"。

	// 成员函数，向缓冲区添加精灵帧对象
	void addSpriteFrame(SpriteFrame *frame, const std::string& frameName);

	// 成员函数，移除缓冲区中的精灵帧对象
	void removeSpriteFrames(void);

3）为一组相关的对象提供一个统一的全局访问点，还可以提供一些简洁的接口来获取和操作这些对象。同时使用此模式来缓存游戏中的常用资源，可以提高游戏运行时性能。例如纹理缓冲区就为开发者提供了许多便利的条件。开发者通过调用一个函数就可以将缓冲区中没有使用的纹理资源释放。

	// 将纹理对象添加至缓冲区
	Texture2D* addImage(std::string& filepaht);

	// 移除缓冲区所有纹理对象
	void removeAllTextures();

	// 移除未使用的纹理对象
	removeUnusedTextures();

	// 释放指定的纹理对象
	void removeTexture(Texture2d* texture);

	// 移除指定文理对象，参数为文理对象名字
	void removeTextureForkey(const std::string& key);

### 2.缓冲区

对于频繁出现的对象，采用需要创建、不需要释放的原则就不合适了。缓冲区允许开发者将一些频繁使用的对象存储下来，以便在需要的时候，能够快速的访问。

- 创建和释放都是比较耗费性能的操作。
- 游戏中场景切换时，是释放缓冲区的最好时机。
- 虽然在程序退出，缓冲区会自动创建删除。但是在运行期间，开发者需要手动调用函数进行清理。