---
title: 1. 内存管理
categories: Cocos2d-Lua
---

C++中，动态内存分配是一把双刃剑，一方面直接访问内存提高了应用程序的性能及内存使用的灵活性;另一方面，由于没有正确的分配与释放内存造成的野指针、重复释放、内存泄露又严重影响着应用程序的稳定性。

人们尝试用智能指针、自动垃圾回发等进行C++内存管理，但这些要么影响了应用程序的性能，要么仍然需要开发者注意一些规则。

因为优秀的C++内存管理方案需要兼顾性能和易用性，到目前为此C++标准中都没有给出真正的内存管理方案。

### 1.C++显式堆内存管理

C++使用new关键字时在运行时给对象动态分配内存，并返回堆上内存的地址供程序访问，当对象不再使用时delete运算符将内存释放。

不能正确处理堆内存的分配与释放通常会导致以下问题：

1）.野指针。指针指向的内存单元已经释放，但是其他的指针还可能指向它，这些内存很可能已经重新分配给其他对象，从而导致无法取得正确的结果。

2）.重复释放。释放一个已经被释放的内存单元，或者释放一个野指针。

3）.内存泄露。不再使用的内存单元没有被释放，导致内存占用不断增加。

### 2.智能指针

C++有三种管理内存方式，自动存储、静态存储、动态存储。

1).静态存储用于存储一些在整个应用程序执行期间都存在的静态变量。

2).动态存储用于存储通过new分配的内存单元。

3).自动存储用于函数内部自定义的常规变量。自动变量在函数被调用时自动产生，在函数结束时消亡。

由于自动变量不会导致内存问题，所以智能指针试图通过将一个动态分配的内存与一个自动变量相关联，让这个自动变量自动释放的时候释放其所管理指针的内存单元，这使不再需要显式地调用delete运算符就可以很好地管理动态分配内存。

##### 2.1 智能指针

C++使用三种不同的智能指针，分别是unique_ptr、shared_ptr、weak_ptr都属于模板类型。

	int main
	{
		unique_ptr<int> up1(new int(11));
		unique_ptr<int> upll = upl;	// 编译报错

		shared_ptr<int> up2(new int(22));
		weak_ptr<int> up3 = up2;
	}

	(1)unique_ptr：不能与其他指针共享所指对象的内存。如将up1赋给up11将导致编译错误。可以通过标准库的move函数来转移unique_ptr指针对象的所有权。

	(2)shared_ptr：可以共享同一堆分配对象的内存，采用引用计数，只有归零时，才会释放所占的所有的堆内存。

	(3)weak_ptr：用来指向shared_ptr指针分配的对象内存，但不拥有该内存。

##### 2.2 为什么不使用智能指针？

shared_ptr是一个完美有内存管理方案，实际上至少有两个原因使Cocos2d-x不应该使用智能指针。

1).较大的性能损耗。 shared_ptr为了保证线程安全，必须使用一定形式的互斥锁来保证所有线程访问时其引用计数正确。

2).仍然需要显式的声明智能指针。另外，在需要引用的地方，一般使用weak_ptr指针的引用 ，示例如下：

	weak_ptr<Node*> refNode = node;

### 3.垃圾回发

垃圾回收主要有如下两种方式：

1）基于引用计数

当对象引用计数变为零时，该对象会被视作垃圾而被回收。

2）基于跟踪处理

先产生跟踪对象的关系图，再进行垃圾回收。

### 4.智能指针的变体——Cocos内存管理

Cocos2d-x内存管理机制可以看成基于智能指针的一个变体，但它同时使程序可以像使用垃圾回收机制那样不需要声明智能指针。